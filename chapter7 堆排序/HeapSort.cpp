#include <iostream>
using namespace std;
/***************************************************************************************************
它是稳定排序，时间复杂度稳定保持在O(n * log(n))，空间复杂度为O(1)
那堆排序有什么不如快速排序的呢？应该是输在常系数上了，从代码里可以看到堆排序在随机访问元素的时候，
下标的变化很大。如果你还考虑了内存里数据寻址的耗时，那么快速排序、归并排序要访问的内存总是
离得更近（人家用的是++和--），这样就不会像堆排序那样到处寻址了。
***************************************************************************************************/
void PercolateDown(int a[], int pos,int n)
{
	int i, child;
	int temp = a[pos];
	for (i = pos; 2 * i + 1 < n; i=child)
	{
		/***************************************************************
		i从0开始，leftchild= 2 * i + 1;
		数组的界限是n-1,所以child不能为n-1，不然测试a[child+1]就会越界
		***************************************************************/
		child = 2 * i + 1;
		if (child != n - 1 && a[child + 1] > a[child])
		{
			child++;
		}
		if (temp < a[child])
		{
			a[i] = a[child];
		}
		else
		{
			break;
		}
	}
	a[i] = temp;
}
void Swap(int &a, int &b)
{
	int temp = a;
	a = b;
	b = temp;
}
void HeapSort(int a[], int n)
{
	for (int i = n / 2; i >= 0; i--)
	{
		PercolateDown(a, i, n);
	}
	for (int i = n - 1; i > 0; i--)
	{
		Swap(a[0], a[i]);
		/**********************************************************************
		在swap后最大的元素沉底,不会被当做child参与到PercolateDown中
		通过传递的 i=n-1 来保证，实际的判断条件是 child!=n-1-1，
		那么在child=n-1-1时，child+1就是沉底的元素，但是因为有child != n - 1
		这个判断条件，child就不会加1，沉底元素也就不会被调用
		**********************************************************************/
		PercolateDown(a, 0, i);
	}
}
void main()
{
	int a[] = { 34,8,64,51,32,21 };
	HeapSort(a, 6);
	for (int i = 0; i < 6; ++i)
	{
		cout << a[i] << " ";
	}
	cin.get();
}